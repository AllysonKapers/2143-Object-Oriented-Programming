<html>
<head><title>Chapter 11, Outline</title></head>
<body >
<h1 ALIGN=center>Introduction to Object Oriented Programming, 3rd Ed</h1>
<h2 ALIGN=center><a href="http://www.cs.orst.edu/~budd/">Timothy A. Budd</a></h2>
<h1 ALIGN=center>Chapter 11</h1>
<h1 ALIGN=center>Static and Dynamic Behavior</h1>
<p>
<b>Outline</b>
<ol>
<li><a href="slide01.htm"> Roadmap </a>
<li><a href="slide02.htm"> What do the terms Static and Dynamic mean? </a>
<li><a href="slide03.htm"> Static and Dynamic Typing </a>
<ol>
<li><a href="slide04.htm"> Arguments for and Against </a>
</ol>
<li><a href="slide05.htm"> The Polymorphic Variable </a>
<li><a href="slide06.htm"> Static Class and Dynamic Class </a>
<li><a href="slide07.htm"> Importance of the Static Class </a>
<li><a href="slide08.htm"> Reverse Polymorphism </a>
<ol>
<li><a href="slide09.htm"> Two aspects of Reverse Polymorphism </a>
<li><a href="slide10.htm"> The container Problem </a>
</ol>
<li><a href="slide11.htm"> Static and Dynamic Method Binding </a>
<ol>
<li><a href="slide12.htm"> Documenting Method Binding </a>
<li><a href="slide13.htm"> Method Binding in C++ </a>
<li><a href="slide14.htm"> Merits of Static versus Dynamic Method Binding </a>
</ol>
<li><a href="slide15.htm"> Chapter Summary </a>
</ol>
<p><b>Other Material</b>
<ul>
<li>A printer friendly version of <a href="all.htm">all slides</a>
</ul>

<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Outline</h6>
<hr>


<p>
<h1>Roadmap</h1>
In this chapter we will examine how differences in static and dynamic features
effect object-oriented programming languages.
<ul>
<li>Static versus Dynamic Typing
<p><li>Static and Dynamic Classes in Statically Typed Languages
<p><li>Static and Dynamic Method Binding in Statically Typed Languages
</ul>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 01</h6>
<hr>
</body>
<p>
<h1>What do the terms Static and Dynamic Mean?</h1>
In Programming languages:
<ul>
<li>Static almost always means fixed or bound at compile time, and cannot
thereafter be changed.
<p><li>Dynamic almost always means not fixed or bound until run time, and
therefore can change during the course of execution.
</ul>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 02</h6>
<hr>
</body>
<p>
<h1>Static and Dynamic Typing</h1>
In a statically typed programming language (Java or Pascal), for example, variables have
declared typed -- fixed at compile time.
<p>
In a dynamically typed programming language (Smalltalk or CLOS), a variable
is just a name.  Types are associated with values, not variables.
A variable can hold different types during the course of execution.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 03</h6>
<hr>
</body>
<p>
<h1>Arguments for and Against</h1>
Static and Dynamically typed languages have existed as long as 
there have been programming languages.  Arguments for and against:
<ul>
<li>Static typing allows better error detection, more work at compile time
and hence faster execution time.
<p><li>Dynamic typing allows greater flexibility, easier to write (for
example, no declaration statements).
</ul>
Both arguments have some validity, and hence both types of languages will
continue to exist in the future.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 04</h6>
<hr>
</body>
<p>
<h1>The Polymorphic Variable</h1>
The addition of object-oriented ideas in a statically typed languages adds
a new twist.  Recall the argument for substitution: an instance of a child
class should be allowed to be assigned to a variable of the parent class:
<pre>
var
	pet : Mammal;
	fido : Dog;
	felice: Cat;
begin
	pet := fido; // legal
	pet := felice; // legal
	fido := pet; // not legal!
</pre>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 05</h6>
<hr>
</body>
<p>
<h1>Static Class and Dynamic Class</h1>
In a statically typed language we say the class of the declaration is
the <b>static class</b> for the variable, while the class
of the value it currently holds is the <b>dynamic class</b>.
<p>
Most statically typed OO languages constrain the dynamic class to be
a child class of the static class.
<pre>
var
	pet : Mammal;
	fido : Dog
begin
	pet := fido; // static class is <b>Mammal</b>, dynamic class is <b>Dog</b>
end;
</pre>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 06</h6>
<hr>
</body>
<p>
<h1>Importance of Static Class</h1>
In a statically typed object-oriented language, the <b>legality</b> of a
message is determined at <b>compile time</b>, based on the static class.
<p>
A message can produce a compile error, even if no run-time error could
possibly arize:
<pre>
class Mammal { }
class Dog extends Mammal { 
	void speak() { System.out.println("woof"); }
}

Mammal pet = new Dog;
pet.speak(); // will generate error, Mammals don't speak
</pre>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 07</h6>
<hr>
</body>
<p>
<h1>Reverse Polymorphism</h1>
<P>
Polymorphism says we can assign a value from a child class to an instance of 
the parent class, but can this assignment then be reversed?  Under what 
conditions?
<P>
<pre>
var
	pet : Mammal;
	fido : Dog;
	felice : Cat;
begin
	pet := fido;	// legal
	fido := pet;	// is this legal? 
end;
</pre>
<br>
This is known as the problem of <EM>reverse polymorphism</EM>.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 08</h6>
<hr>
</body>
<p>
<h1>Two aspects of reverse polymorphism</h1>
<P>
There are two specific problems associated with the question of reverse
polymorphism.
<P><UL>
<LI>
The problem of identity - can I tell if a value declared as an instance of
a parent class actually holds a value from a subclass.
<p>
<LI>
The task of assignment - can I then assign the value from the parent class
to a variable declared as the subclass.
</UL>
<P>
In some languages mechanisms are provided to address these two problems 
together, while in other languages they are separated.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 09</h6>
<hr>
</body>
<p>
<h1>The Container Problem</h1>
<P>
The task of reverse polymorphism is often encountered in connection with
a collection of values - we have a list of items from the parent class
(say a list of Mammals), and when we extract a value we need to
know if it is a more specific type.
<P>
Generally occurs in languages with a single inheritance tree, where the
only type we may have associated with a value is the class ``Object''.
<P>
Solving this problem generally requires values to have ``self knowledge''
of their own type.  In some languages they do, in some languages values
do not.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 10</h6>
<br>
A case study examining one solution to the container class problem will
be presented in a later chapter.
<br>
Java, unfortunately, uses to term <b>Container</b> to mean a type of graphical
component, and not a collection class, as is common in most other languages.
<hr>
</body>
<p>
<h1>Static and Dynamic Method Binding</h1>
<P>
Should the binding for information be associated with the static class of
a variable or the dynamic class.
<P>
Alice holds a small Mammal - asks Bill ``does this animal give birth to live
young''.
<P>
Static answer - All mammals give birth to live young - therefore yes.
<P>
What if the Mammal is a platypus?  Dynamic answer - Platypus lay eggs,
therefore no.
<P>
Even statically typed OOP languages can use dynamic binding.
But may use static type to determine legality of operation.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 11</h6>
<hr>
</body>
<p>
<h1>Documenting Method Binding</h1>
In many languages dynamic binding is the default.  If a child class overrides
a method in the parent, using the same type signature, then the selected
method will be determined by the dynamic type.
<p>
In other languages (C++, Delphi, C#) the programmer must indicate which
methods are dynamically bound and which are statically type.
In C#, for example, this is done using the <b>virtual</b> keyword.
</font>
<table><tr><td><pre>
class Animal {
public:
	virtual void speak () { cout << "Animal Speak !\n"; }
	void reply () { cout << "Animal Reply !\n"; }
};

class Dog : Animal {
public:
	override void speak () { cout << "woof !\n"; }
	void reply () { cout << "woof again!\n"; }
};

class Bird : Animal {
public:
	virtual void speak () { cout << "tweet !\n"; }
};
</font>
</pre><td><pre>
	Animal a;
	Dog b;
	b.speak();
woof !
	a  = b;
	a.speak();
woof !
	Bird c;
	c.speak();
tweet !
	a = c;
	a.speak();
tweet !
</font>
</pre></table>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 12</h6>
<hr>
</body>
<p>
<h1>Method Binding in C++</h1>
C++ is the most complex language.  Not only must the programmer
use the <b>virtual</b> keyword, but true polymorphism only occurs
with pointer or reference variables.
</font>
<table><tr><td><pre>
class Animal {
public:
	virtual void speak () { cout << "Animal Speak !\n"; }
	void reply () { cout << "Animal Reply !\n"; }
};

class Dog : public Animal {
public:
	virtual void speak () { cout << "woof !\n"; }
	void reply () { cout << "woof again!\n"; }
};

class Bird : public Animal {
public:
	virtual void speak () { cout << "tweet !\n"; }
};
</font>
</pre><td><pre>
	Animal * a;
	Dog * b = new Dog();
	b->speak();
woof !
	a  = b;
	a->speak();
woof !
	Bird c = new Bird();
	c->speak();
tweet !
	a = c;
	a->speak();
tweet !
</font>
</pre></table>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 13</h6>
<br>
We will see an explanation for the curious C++ semantics when we discuss
memory management in the next chapter.
<hr>
</body>
<p>
<h1>Merits of Static versus Dynamic Method Binding</h1>
<P>
Arguments concerning static versus dynamic binding mirror those 
concerning static versus dynamic typing.
<P><UL>
<LI>
Efficiency - static binding uses least CPU cycles, dynamic binding requires
more time.
<p>
<LI>
Error detection - static binding permits errors to be caught at compile time
rather than run-time.
<p>
<LI>
Flexibility - dynamic binding permits greater flexibility,
static binding creates rigidity and inhibits reuse.
</UL>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 14</h6>
<hr>
</body>
<p>
<h1>Chapter Summary</h1>
<ul>
<li>A statically typed language associated types with variables,
a dynamically typed language associates types with values.
<p><li>Static typing gives better error detection, better run-time
efficiency, less flexibility.
<p><li>In a statically typed OO language, an object variable can still
hold values from a child class.
<p><li>The static class is the class of the declaration, the dynamic
class is the class of the value currently held.
<p><li>The legality of a message is checked using the static class.
<p><li>A message can be bound to a method using either the static
or dynamic class.  Most languages use the dynamic class.
Some languages allow the programmer to choose which method is used.
</ul>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 11</a>, Slide 15</h6>
<hr>
</body>
</body>
</html>
