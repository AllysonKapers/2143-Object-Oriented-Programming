<html>
<head><title>Chapter 2, Outline</title></head>
<body >
<h1 ALIGN=center>Introduction to Object Oriented Programming, 3rd Ed</h1>
<h2 ALIGN=center><a href="http://www.cs.orst.edu/~budd/">Timothy A. Budd</a></h2>
<h1 ALIGN=center>Chapter 2</h1>
<h1 ALIGN=center>Abstraction </h1>
<p>
<b>Outline</b>
<ol>
<li><a href="slide01.htm"> Roadmap</a>
<li><a href="slide02.htm"> Abstraction</a>
<li><a href="slide03.htm"> Information Hiding</a>
<li><a href="slide04.htm"> Abstraction in an Atlas</a>
<li><a href="slide05.htm"> Levels of Abstraction in OO Programs</a>
<ol>
<li><a href="slide06.htm"> Packages and Name Spaces</a>
<li><a href="slide07.htm"> Clients and Servers</a>
<li><a href="slide08.htm"> Description of Services</a>
<li><a href="slide09.htm"> Interfaces</a>
<li><a href="slide10.htm"> An Implementation of an Interface</a>
<li><a href="slide11.htm"> A Method in Isolation</a>
</ol>
<li><a href="slide12.htm"> Finding the Right Level of Abstraction</a>
<li><a href="slide13.htm"> Forms of Abstraction</a>
<ol>
<li><a href="slide14.htm"> Is-a and Has-A Abstraction</a>
<ol>
<li><a href="slide15.htm"> Has-A Abstraction</a>
<li><a href="slide16.htm"> Is-A Abstraction</a>
</ol>
<li><a href="slide17.htm"> Encapsulation and Interchangeability</a>
<li><a href="slide18.htm"> The Service View</a>
<li><a href="slide19.htm"> Other Types of Abstraction -- Composition</a>
<li><a href="slide20.htm"> Patterns</a>
</ol>
<li><a href="slide21.htm"> A Short History of Abstraction Mechanisms</a>
<ol>
<li><a href="slide22.htm"> Assembly Languages</a>
<li><a href="slide23.htm"> Procedures and Functions</a>
<li><a href="slide24.htm"> Information Hiding -- The Problem of Stacks</a>
<li><a href="slide25.htm"> Modules</a>
<li><a href="slide26.htm"> Parnas's Principles</a>
<li><a href="slide27.htm"> Abstract Data Types</a>
<li><a href="slide28.htm"> Three Eons of History</a>
<li><a href="slide29.htm"> Objects- ADT's with Message Passing</a>
</ol>
<li><a href="slide30.htm"> What does the Future Hold?</a>
</ol>
<p><b>Other Material</b>
<ul>
<li>A printer friendly version of <a href="all.htm">all slides</a>
</ul>

<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Outline</h6>
<hr>


<p>
<h1>Roadmap</h1>
In this chapter we will consider abstraction, which is <i>the</i> most 
important tool used in the control of complexity.
<p>
We will examine various abstraction mechanisms
<p>
We will present a short history of the development of abstraction tools.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 01</h6>
<hr>
</body>
<p>
<h1>Abstraction</h1>
Abstraction is the purposeful suppression, or hiding, of some
details of a process or artifact, in order to bring out more
clearly other aspects, details, or structure.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 02</h6>
<hr>
</body>
<p>
<h1>Information Hiding</h1>
Information hiding is the purposeful omission of details
in the development of an abstract representation.
<p>
Information hiding is what allows abstraction to control complexity.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 03</h6>
<hr>
</body>
<p>
<h1>Abstraction in an Atlas</h1>
Think of an atlas, and the various different levels of maps
<ul>
<li>A map of the world, contains mountain ranges, large political boundaries
<p><li>A map of a contenent, contains all political boundaries, large cities
<p><li>A map of a country, contains more cities, major roads
<p><li>A map of a large city, roads, major structures
<p><li>A map of a portion of a city, buildings, occupants
</ul>
Each level contains information appropriate to the level of abstraction.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 04</h6>
<hr>
</body>
<p>
<h1>Levels of Abstraction in OO Programs</h1>
At the highest level of abstraction we view a program as
a community of interacting objects.
<p>
<img src="slide05.gif">
<p>
Important characteristics here are the lines of communication between
the various agents.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 05</h6>
<hr>
</body>
<p>
<h1>Abstraction in OO Programs -- Packages and Name spaces</h1>
The next level of abstraction is found in some (but not all) OO languages.
A package, Unit or Name Space allows a programmer to surround a collection
of objects (a small community in itself) with a layer, and control visibility
from outside the module.
<p>
<img src="slide06.gif">
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 06</h6>
<hr>
</body>
<p>
<h1>Abstraction in OO Languages -- Clients and Servers</h1>
The next level of abstraction considers the relationship between
two invidual objects.  Typically one is providing a service, and the
other is using the service.
<p>
<img src="slide07.gif">
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 07</h6>
<hr>
</body>
<p>
<h1>Abstraction in OO languages -- Description of Services</h1>
We can next examine just the person providing a service, independent of
the client.  We define the nature of the services that are offered, but
not how those services are realized.
<p>
<img src="slide08.gif">
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 08</h6>
<hr>
</body>
<p>
<h1>Levels of Abstraction in OO -- Interfaces</h1>
Interfaces are one way to describe servies at this level of abstraction.
<pre>
interface Stack {
	public void push (Object val);
	public Object top () throws EmptyStackException;
	public void pop () throws EmptyStackException;
}
</pre>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 09</h6>
<hr>
</body>
<p>
<h1>Levels of Abstraction -- An Implementation</h1>
Next we look at the services provided, but from the implementation side:
<pre>
public class LinkedList implements Stack ... {
	public void pop () throws  EmptyStackException { ... }
	...
}
</pre>
Concern here is with the high level approach to providing the
designated service.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 10</h6>
<hr>
</body>
<p>
<h1>Levels of Abstraction -- A Method in Isolation</h1>
Finally, we consider the implementation of each method in isolation.
<pre>
public class LinkedList implements Stack ... {
	...
	public void pop () throws  EmptyStackException { 
		if (isEmpty())
			throw new EmptyStackException();
		removeFirst(); // delete first element of list
	}
	...
}
</pre>
Every level is important, and often you move quickly back and forth 
between levels.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 11</h6>
<hr>
</body>
<p>
<h1>Finding the Right Level of Abstraction</h1>
A critical problem in early stages of development is to determine
what details are appropriate at each level of abstraction,
and (often more importantly) what details should be omitted.
<p>
One does not want to ignore or throw away important information
<p>
But one does not want to manage too much information, or have the
amount of information hide critical details.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 12</h6>
<hr>
</body>
<p>
<h1>Forms of Abstraction</h1>
<img src="slide13.gif">
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 13</h6>
<hr>
</body>
<p>
<h1>Is-a and Has-A abstraction</h1>
Two of the most important types of abstraction are the following:
<ul>
<li>Division into parts -- Has-a abstraction
<p><li>Division into specialization -- Is-a abstraction
</ul>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 14</h6>
<hr>
</body>
<p>
<h1>Has-A Abstraction</h1>
Division into parts takes a complex system, and divides into into component
parts, which can then be considered in isolation.
<p>
Characterized by sentences that have the words ``has-a''
<ul>
<li>A car has-a engine, and has-a transmission
<p><li>A bicycle has-a wheel
<p><li>A window has-a menu bar
</ul>
Allows us to drop down a level of complexity when we consider the
component in isolation.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 15</h6>
<hr>
</body>
<p>
<h1>Is-a Abstraction</h1>
Is-a abstraction takes a complex system, and views it as an instance of
a more general abstraction.
<p>
Characterized by sentences that have the words ``is=a''
<ul>
<li>A car is a wheeled vehicle, which is-a means of transportation
<p><li>A bicycle is-a wheeled vehicle
<p><li>A pack horse is-a means of transportation
</ul>
Allows us to categorize artifacts and information and make it applicable to many
different situations.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 16</h6>
<hr>
</body>
<p>
<h1>Encapsulation and Interchangeability</h1>
An important aspect of division into parts is to clearly characterize the
connection, or <i>interface</i>, between to components.
<p>
Allows for considering multiple different <i>implementations</i> of the
same interface.
<p>
For example, a 
car can have several different types of engine and one transmission.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 17</h6>
<hr>
</body>
<p>
<h1>The Service View</h1>
Another way to think of an interface is as a way of describing the 
<i>service</i> that an object provides.
<p>
The interface is a contract for the service--if the interface is upheld, then
the service will be provided as described.
<p>
<img src="slide08.gif">
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 18</h6>
<hr>
</body>
<p>
<h1>Other Types of Abstraction -- Composition</h1>
While is-a and has-a are two important types of abstraction, there are others.
<p>
Composition is one example; a form of has-a; characterized by the following
<ul>
<li>Primitive forms 
<p><li>Rules for combining old values to create new values 
<p><li>The idea that new values can also be subject to further combination
</ul>
Examples include regular expressions, type systems, windows, lots of other
complex systems.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 19</h6>
<hr>
</body>
<p>
<h1>Patterns</h1>
Patterns are another attempt to document and reuse abstractions.
<p>
Patterns are description of proven and useful relationships between
objects; which can help guide the solution of new problems.
<p>
Example pattern, Proxy:
<p>
<img src="slide20.gif">
<p>
Will have many more patterns in a later chapter.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 20</h6>
<hr>
</body>
<p>
<h1>A Short History of Abstraction Mechanisms</h1>
Another way to better understand OOP is to put it in context with the
history of abstraction in computer science.
<ul>
<li>Assembly languages
<li>Procedures
<li>Modules
<li>ADT
<li>The Service View
<li>Objects
<p>
<li>The future....
</ul>

</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 21</h6>
<hr>
</body>
<p>
<h1>Assembly Languages</h1>
<p>
Assembly languages and linkers were perhaps the first tools used to 
abstract features of the bare machine.
<p>
<ul>
<p>
<li>Addresses could be represented symbolically, not as a number.
<p>
<li>Symbolic names for operations.
<p>
<li>Linking of names and locations performed automatically
</ul>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 22</h6>
<hr>
</body>
<p>
<h1>Procedures and Functions</h1>
<p>
Libraries of procedures and functions (such as mathematical or input/output 
libraries) provided the first hints of <i>information hiding</i>.
<p>
They permit the programmer to think about operations in high level terms,
concentrating on <i>what</i> is being done, not <i>how</i> it is 
being performed.
<p>
But they are not an entirely effective mechanism of information hiding.
<p>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 23</h6>
<hr>
</body>
<p>
<h1>Information Hiding -- The Problem of Stacks</h1>
<p>
<pre>
int datastack[100];
int datatop = 0;

void init()     // initialize the stack
{ datatop = 0; }

void push(int val)   // push a value on to the stack
{ if (datatop < 100)
		datastack [datatop++] = val; }

int top()   // get the top of the stack
{ if (datatop > 0)
		return datastack [datatop - 1];
	return 0; }

int pop()   // pop element from the stack
{ if (datatop > 0)
		return datastack [--datatop]; 
	return 0; }
</pre>
Where can you hide the implementation?
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 24</h6>
<hr>
</body>
<p>
<h1>Modules</h1>
<p>
Modules basically provide collections of procedures and data with import 
and export statements
<p>
Solves the problem of encapsulation -- but what if your programming task requires
two or more stacks?
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 25</h6>
<hr>
</body>
<p>
<h1>Parnas's Principles</h1>
<p>
David Parnas described two principles for the proper use of modules:
<ul>
<p><li>
One must provide the intended user of a module with all the information 
needed to use the module correctly, and with <i>nothing more</i>.
<p><li> One must provide the implementor of a module with all the information
needed to complete the module, and <i>nothing more</i>.
</ul>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 26</h6>
<hr>
</body>
<p>
<h1>Abstract Data Types</h1>
<p>
An <i>Abstract Data Type</i> is a programmer-defined data type that can be
manipulated in a manner similar to system-provided data types
<ul>
<p><li>Must have the ability to instantiate many different copies of the data type.
<p><li>Data type can be manipulated using provided operations, 
without knowledge of internal representation.
</ul>
But ADTs were important not because they were data structures, but because
they provided an easily characterized service to the rest of an application.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 27</h6>
<hr>
</body>
<p>
<h1>Three Eons of History</h1>
Looking at this history, we can separate it into three periods of time
<p>
<table border=1>
<br>functionality of an application
<br>data types used in an application
<br>services provided by objects in the application
</table>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 28</h6>
<hr>
</body>
<p>
<h1>Objects - ADT's with Message Passing</h1>
<p>
Characterists of Objects
<ul>
<p><li>
Encapsulation -- similar to modules
<p><li>
Instantiation -- similar to ADT's
<p><li>
Messages -- dynamic binding of procedure names to behavior
<p><li>
Classes -- a way of organization that permits sharing and reuse
<p><li>
Polymorphism -- A new form of software reuse using dynamic binding
</ul>
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 29</h6>
<hr>
</body>
<p>
<h1>What Does the Future Hold</h1>
What will be the next evolutionary step in software?
<p>
Prediction is hard, particularly about the future.
<p>
However, one you have accepted the idea of an application formed from
interacting agents, there is no reason why those components must exist
on the same computer (distributed computing) or be written in the
same language (components).
<p>
So some of the trends we see today in software are natural results
of the OOP mind set.
</font>
<h6 ALIGN=right>Intro OOP, <a href="outline.htm">Chapter 2</a>, Slide 30</h6>
<hr>
</body>
</body>
</html>
